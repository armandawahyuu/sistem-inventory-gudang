#!/usr/bin/env node

/**
 * Security Penetration Test Script
 * Tests for SQL Injection, XSS, Authentication, Rate Limiting
 * 
 * Usage: node scripts/security-pentest.js
 * 
 * Requirements:
 * - Application must be running on localhost:3000
 */

const BASE_URL = process.env.TEST_URL || 'http://localhost:3000';

// Colors for console output
const colors = {
    reset: '\x1b[0m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    cyan: '\x1b[36m',
    magenta: '\x1b[35m',
};

const log = {
    info: (msg) => console.log(`${colors.blue}ℹ${colors.reset} ${msg}`),
    pass: (msg) => console.log(`${colors.green}✓ PASS${colors.reset} ${msg}`),
    fail: (msg) => console.log(`${colors.red}✗ FAIL${colors.reset} ${msg}`),
    warn: (msg) => console.log(`${colors.yellow}⚠${colors.reset} ${msg}`),
    title: (msg) => console.log(`\n${colors.cyan}═══ ${msg} ═══${colors.reset}`),
    section: (msg) => console.log(`\n${colors.magenta}▸ ${msg}${colors.reset}`),
};

let passed = 0;
let failed = 0;

// Helper to make HTTP requests
async function request(url, options = {}) {
    try {
        const response = await fetch(url, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers,
            },
        });

        let body = null;
        try {
            body = await response.text();
            body = JSON.parse(body);
        } catch {
            // Keep as text if not JSON
        }

        return { status: response.status, body, headers: response.headers };
    } catch (error) {
        return { error: error.message };
    }
}

// ============================================
// TEST 1: SQL INJECTION
// ============================================
async function testSQLInjection() {
    log.title('SQL INJECTION TESTS');

    const payloads = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM users --",
        "1; SELECT * FROM users",
        "admin'--",
        "' OR 1=1 --",
    ];

    log.section('Testing login endpoint');

    for (const payload of payloads) {
        const result = await request(`${BASE_URL}/api/auth/callback/credentials`, {
            method: 'POST',
            body: JSON.stringify({
                username: payload,
                password: payload,
            }),
        });

        // Should NOT return success or expose data
        if (result.status === 200 && result.body?.user) {
            log.fail(`SQL Injection succeeded with payload: ${payload}`);
            failed++;
        } else {
            log.pass(`Blocked payload: ${payload.slice(0, 30)}...`);
            passed++;
        }
    }

    log.section('Testing search/filter endpoints');

    // Test search parameter
    const searchResult = await request(`${BASE_URL}/api/master/sparepart?search=${encodeURIComponent("' OR '1'='1")}`);

    if (searchResult.status === 200 && Array.isArray(searchResult.body?.data)) {
        // Check if it returned all records (SQL injection success)
        if (searchResult.body.data.length > 100) {
            log.fail('Search endpoint may be vulnerable to SQL injection');
            failed++;
        } else {
            log.pass('Search endpoint properly escapes SQL');
            passed++;
        }
    } else {
        log.pass('Search endpoint rejected malicious input');
        passed++;
    }
}

// ============================================
// TEST 2: XSS (Cross-Site Scripting)
// ============================================
async function testXSS() {
    log.title('XSS TESTS');

    const payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg onload=alert('XSS')>",
        "'><script>alert(String.fromCharCode(88,83,83))</script>",
        "<body onload=alert('XSS')>",
        "<iframe src=\"javascript:alert('XSS');\">",
    ];

    log.section('Testing input sanitization');
    log.info('Note: Full XSS test requires browser. Testing API-level sanitization.');

    // Test creating kategori with XSS payload
    for (const payload of payloads.slice(0, 3)) {
        const result = await request(`${BASE_URL}/api/master/kategori`, {
            method: 'POST',
            body: JSON.stringify({
                name: payload,
            }),
        });

        // Check if payload is stored as-is or sanitized/rejected
        if (result.status === 401) {
            log.pass(`Endpoint requires auth (XSS payload not tested): ${payload.slice(0, 20)}...`);
            passed++;
        } else if (result.body?.name?.includes('<script>')) {
            log.fail(`XSS payload stored unsanitized: ${payload.slice(0, 20)}...`);
            failed++;
        } else {
            log.pass(`XSS payload handled: ${payload.slice(0, 20)}...`);
            passed++;
        }
    }

    log.info('Browser-level XSS is prevented by:');
    log.info('- Content-Security-Policy header');
    log.info('- React automatic escaping');
    log.info('- DOMPurify sanitization');
}

// ============================================
// TEST 3: AUTHENTICATION
// ============================================
async function testAuthentication() {
    log.title('AUTHENTICATION TESTS');

    log.section('Testing protected routes without login');

    const protectedRoutes = [
        '/api/master/sparepart',
        '/api/master/kategori',
        '/api/transaksi/barang-masuk',
        '/api/dashboard',
    ];

    for (const route of protectedRoutes) {
        const result = await request(`${BASE_URL}${route}`);

        if (result.status === 401 || result.status === 403) {
            log.pass(`Route ${route} requires authentication`);
            passed++;
        } else if (result.status === 200) {
            log.fail(`Route ${route} accessible without authentication!`);
            failed++;
        } else {
            log.pass(`Route ${route} protected (status: ${result.status})`);
            passed++;
        }
    }

    log.section('Testing brute force protection');

    let blockedCount = 0;
    const maxAttempts = 10;

    for (let i = 0; i < maxAttempts; i++) {
        const result = await request(`${BASE_URL}/api/auth/callback/credentials`, {
            method: 'POST',
            body: JSON.stringify({
                username: 'admin',
                password: 'wrongpassword',
            }),
        });

        if (result.status === 429) {
            blockedCount++;
            log.pass(`Rate limited after ${i + 1} attempts`);
            passed++;
            break;
        }

        // Small delay between attempts
        await new Promise(r => setTimeout(r, 100));
    }

    if (blockedCount === 0) {
        log.warn(`No rate limiting detected after ${maxAttempts} attempts`);
        log.info('This may be OK if using different rate limit strategy');
    }
}

// ============================================
// TEST 4: AUTHORIZATION (IDOR)
// ============================================
async function testAuthorization() {
    log.title('AUTHORIZATION TESTS (IDOR)');

    log.section('Testing direct object reference');

    // Try to access resources with random IDs
    const randomIds = [
        'clxxxxxxxxxxxxxxxxxxxxxxxxxx',
        '../../etc/passwd',
        '../admin',
        '1 OR 1=1',
    ];

    for (const id of randomIds) {
        const result = await request(`${BASE_URL}/api/master/sparepart/${encodeURIComponent(id)}`);

        if (result.status === 404 || result.status === 401 || result.status === 400) {
            log.pass(`Invalid ID properly rejected: ${id.slice(0, 20)}`);
            passed++;
        } else if (result.status === 200 && result.body?.data) {
            log.fail(`Possible IDOR vulnerability with ID: ${id.slice(0, 20)}`);
            failed++;
        } else {
            log.pass(`ID access controlled: ${id.slice(0, 20)}`);
            passed++;
        }
    }
}

// ============================================
// TEST 5: RATE LIMITING
// ============================================
async function testRateLimiting() {
    log.title('RATE LIMITING TESTS');

    log.section('Testing API rate limits');

    const endpoint = `${BASE_URL}/api/master/kategori`;
    let rateLimited = false;
    let requestCount = 0;
    const maxRequests = 150;

    log.info(`Sending ${maxRequests} requests to test rate limiting...`);

    for (let i = 0; i < maxRequests; i++) {
        const result = await request(endpoint);
        requestCount++;

        if (result.status === 429) {
            rateLimited = true;
            log.pass(`Rate limited after ${requestCount} requests`);
            passed++;
            break;
        }

        // Show progress every 50 requests
        if (i > 0 && i % 50 === 0) {
            log.info(`Sent ${i} requests...`);
        }
    }

    if (!rateLimited) {
        log.warn(`No rate limiting after ${requestCount} requests`);
        log.info('Rate limiting may be configured differently or disabled in development');
    }
}

// ============================================
// TEST 6: SECURITY HEADERS
// ============================================
async function testSecurityHeaders() {
    log.title('SECURITY HEADERS TESTS');

    const result = await request(`${BASE_URL}/login`);

    if (result.error) {
        log.fail(`Could not connect to ${BASE_URL}`);
        failed++;
        return;
    }

    const headers = result.headers;

    const requiredHeaders = [
        { name: 'x-content-type-options', expected: 'nosniff' },
        { name: 'x-frame-options', expected: ['DENY', 'SAMEORIGIN'] },
        { name: 'x-xss-protection', expected: '1; mode=block' },
    ];

    const recommendedHeaders = [
        { name: 'strict-transport-security' },
        { name: 'content-security-policy' },
        { name: 'referrer-policy' },
    ];

    log.section('Required headers');

    for (const header of requiredHeaders) {
        const value = headers.get(header.name);

        if (!value) {
            log.warn(`Missing header: ${header.name}`);
        } else if (Array.isArray(header.expected)) {
            if (header.expected.some(e => value.includes(e))) {
                log.pass(`${header.name}: ${value}`);
                passed++;
            } else {
                log.warn(`${header.name} has unexpected value: ${value}`);
            }
        } else if (value.includes(header.expected)) {
            log.pass(`${header.name}: ${value}`);
            passed++;
        } else {
            log.warn(`${header.name} has unexpected value: ${value}`);
        }
    }

    log.section('Recommended headers');

    for (const header of recommendedHeaders) {
        const value = headers.get(header.name);

        if (value) {
            log.pass(`${header.name}: ${value.slice(0, 50)}...`);
            passed++;
        } else {
            log.info(`${header.name}: not set (recommended for production)`);
        }
    }
}

// ============================================
// TEST 7: FILE PATH TRAVERSAL
// ============================================
async function testPathTraversal() {
    log.title('PATH TRAVERSAL TESTS');

    const payloads = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\sam',
        '....//....//....//etc/passwd',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    ];

    for (const payload of payloads) {
        const result = await request(`${BASE_URL}/api/templates/${encodeURIComponent(payload)}`);

        if (result.status === 200 && result.body?.toString().includes('root:')) {
            log.fail(`Path traversal vulnerability detected!`);
            failed++;
        } else {
            log.pass(`Path traversal blocked: ${payload.slice(0, 30)}...`);
            passed++;
        }
    }
}

// ============================================
// MAIN
// ============================================
async function main() {
    console.log(`\n${colors.cyan}╔════════════════════════════════════════════════╗${colors.reset}`);
    console.log(`${colors.cyan}║       SECURITY PENETRATION TEST SCRIPT         ║${colors.reset}`);
    console.log(`${colors.cyan}╚════════════════════════════════════════════════╝${colors.reset}`);

    console.log(`\nTarget: ${BASE_URL}`);
    console.log(`Time: ${new Date().toISOString()}\n`);

    // Check if server is running
    const healthCheck = await request(`${BASE_URL}/api/auth/providers`);
    if (healthCheck.error) {
        log.fail(`Cannot connect to ${BASE_URL}`);
        log.info('Make sure the application is running: npm run dev');
        process.exit(1);
    }

    log.pass('Server is reachable');

    // Run all tests
    await testSQLInjection();
    await testXSS();
    await testAuthentication();
    await testAuthorization();
    await testRateLimiting();
    await testSecurityHeaders();
    await testPathTraversal();

    // Summary
    log.title('SUMMARY');

    const total = passed + failed;
    const passRate = ((passed / total) * 100).toFixed(1);

    console.log(`\nTotal tests: ${total}`);
    console.log(`${colors.green}Passed: ${passed}${colors.reset}`);
    console.log(`${colors.red}Failed: ${failed}${colors.reset}`);
    console.log(`Pass rate: ${passRate}%`);

    if (failed === 0) {
        log.pass('All security tests passed! ✨');
    } else {
        log.fail(`${failed} security issue(s) detected - review and fix!`);
    }

    console.log('');
    process.exit(failed > 0 ? 1 : 0);
}

main().catch(console.error);
